<script setup lang="ts">import {convertRegisterKey, convertShow, formatKeyDisplay} from "../../../utils/ShortcutKeys.ts";import EditIcon from "../../../assets/icons/EditIcon.vue";import {currentShortcutKeys, onLoading, originalShortcutKeys} from "../composables/SettingsDataComposable.ts";import {useMessage} from "naive-ui";import {useLanguage} from "../../../services/LanguageService.ts";import {getWakeUpRoutineKeyAvailable} from "../../../store/ShortcutKeyAvailableStatus.ts";import {getSearchKey, getWakeUpRoutine, saveSearchKey, saveWakeUpRoutineKey} from "../../../store/ShortcutKeys.ts";import {error, info} from "@tauri-apps/plugin-log";import {isRegistered, unregister} from "@tauri-apps/plugin-global-shortcut";import {emit} from "@tauri-apps/api/event";import {isMac} from "../../../data/SystemParams.ts";import ErrorIcon from "../../../assets/icons/ErrorIcon.vue";import PassedIcon from "../../../assets/icons/PassedIcon.vue";import HintIcon from "../../../assets/icons/HintIcon.vue";import {onMounted, ref} from "vue";const message = useMessage();const {currentLanguage} = useLanguage();// 当前正在编辑的快捷键const editingShortcut = ref<keyof ShortcutKeys | ''>('');// 临时存储编辑中的按键const tempKeys = ref<string[]>([]);// 快捷键编辑弹窗状态const shortcutModalVisible = ref(false);// 快捷键是否可用const availableKey = ref(true);/** * 开始编辑快捷键 * @param key 快捷键类型 */function startEditShortcut(key: keyof ShortcutKeys) {  editingShortcut.value = key;  tempKeys.value = [...(currentShortcutKeys[key]?.key || [])];  shortcutModalVisible.value = true;  // 如果修改的是唤醒程序快捷键，需要检查快捷键是否可用  if (key.toString() === 'wakeUpRoutine') {    getWakeUpRoutineKeyAvailable().then(available => {      if (available === undefined) {        availableKey.value = true;      } else {        availableKey.value = available;      }    });  } else {    availableKey.value = true;  }  // 打开弹窗后添加全局按键监听  document.addEventListener('keydown', handleKeyDown);}/** * 取消编辑快捷键 */function cancelEditShortcut() {  editingShortcut.value = '';  tempKeys.value = [];  shortcutModalVisible.value = false;  // 关闭弹窗后移除全局按键监听  document.removeEventListener('keydown', handleKeyDown);}/** * 确认编辑快捷键 */async function confirmEditShortcut() {  try {    onLoading.value = true;    const key = editingShortcut.value;    if (key && tempKeys.value.length > 0) {      currentShortcutKeys[key].key = [...tempKeys.value];    }    if (editingShortcut.value === 'wakeUpRoutine') {      await saveWakeUpRoutineKey(currentShortcutKeys[key]);      const keys: string[] = originalShortcutKeys.wakeUpRoutine.key;      info("唤醒程序快捷键已修改，重新注册");      // 重新注册快捷键      const registerKey = convertRegisterKey(keys);      if (await isRegistered(registerKey)) {        // 如果已经注册了快捷键，需要先取消注册，再重新注册        await unregister(registerKey);      }      await emit('update-open-window-key', {keys: currentShortcutKeys});    }    if (editingShortcut.value === 'search') {      await saveSearchKey(currentShortcutKeys[key]);    }    originalShortcutKeys[editingShortcut.value].key = currentShortcutKeys[editingShortcut.value].key;    editingShortcut.value = '';    tempKeys.value = [];    shortcutModalVisible.value = false;    // 关闭弹窗后移除全局按键监听    document.removeEventListener('keydown', handleKeyDown);  } catch (e) {    error('修改快捷键设置出错:' + e);    message.error(currentLanguage.value.pages.settings.saveFailedMsg);  } finally {    onLoading.value = false;  }}/** * 处理按键事件 * @param event 事件 */function handleKeyDown(event: any) {  event.preventDefault();  // 清除之前的按键  tempKeys.value = [];  // 添加修饰键  if (event.ctrlKey) tempKeys.value.push('ctrl');  if (event.shiftKey) tempKeys.value.push('shift');  if (event.altKey) tempKeys.value.push('alt');  if (event.metaKey) tempKeys.value.push('meta');  // 添加主键（如果不是修饰键）  const keyName = event.key.toLowerCase();  if (!['control', 'shift', 'alt', 'meta'].includes(keyName) && keyName !== 'dead') {    tempKeys.value.push(keyName === ' ' ? 'space' : keyName);  }  // 如果修改的是唤醒程序快捷键，需要检查快捷键是否可用  if (editingShortcut.value && editingShortcut.value.toString() === 'wakeUpRoutine') {    checkShortcutKeys();  }}/** * 检查快捷键是否可用 */async function checkShortcutKeys() {  const key = editingShortcut.value || "";  const isUpdate = currentShortcutKeys[key].key === tempKeys.value;  availableKey.value = !isUpdate || await isRegistered(convertRegisterKey(currentShortcutKeys[key].key));}// 加载配置onMounted(async () => {  try {    // 初始化快捷键配置    const searchKey = await getSearchKey();    originalShortcutKeys.search = structuredClone(searchKey);    currentShortcutKeys.search = structuredClone(searchKey);    const wakeUpRoutineKey = await getWakeUpRoutine();    originalShortcutKeys.wakeUpRoutine = structuredClone(wakeUpRoutineKey);    currentShortcutKeys.wakeUpRoutine = structuredClone(wakeUpRoutineKey);  } catch (e) {    console.error('页面初始化失败:', e);    error("页面初始化失败：" + e);    message.error(currentLanguage.value.pages.settings.initFailedHint);  }});</script><template>  <!-- 快捷键设置 -->  <div class="settings-section">    <h2>{{ currentLanguage.pages.settings.shortcutTitle }}</h2>    <div v-for="(shortcut, key) in currentShortcutKeys" :key="key" class="form-item">      <span class="label">{{ currentLanguage.pages.settings[key] }}</span>      <!-- 显示当前快捷键 -->      <div class="shortcut-display">        <div class="shortcut-keys">          <template v-for="(k, index) in shortcut.key" :key="index">            <span class="key-badge">{{ formatKeyDisplay(k) }}</span>            <span v-if="index < shortcut.key.length - 1" class="key-plus">+</span>          </template>        </div>        <span class="edit-icon" @click="startEditShortcut(key)">                <EditIcon/>              </span>      </div>    </div>    <!-- 快捷键编辑弹窗 -->    <n-modal v-model:show="shortcutModalVisible" :title="currentLanguage.pages.settings.editHotkeyModalTitle"             preset="dialog">      <div class="shortcut-modal-content">        <p>{{ currentLanguage.pages.settings.editHotkeyModalContent }}</p>        <div class="shortcut-hint" v-if="!isMac">          <HintIcon class="shortcut-hint-icon"/>          {{ currentLanguage.pages.settings.shortcutHint }}        </div>        <div class="shortcut-keys-select">          {{            convertShow(tempKeys) || currentLanguage.pages.settings.editHotkeyModalHint          }}        </div>        <div class="shortcut-line">          <div class="shortcut-verification" :class="availableKey ? 'key-available': 'key-not-available'">            <PassedIcon v-if="availableKey" class="shortcut-verification-icon"/>            <ErrorIcon v-else class="shortcut-verification-icon"/>            {{              availableKey ? currentLanguage.pages.settings.keyAvailableHint : currentLanguage.pages.settings.keyNotAvailableHint            }}          </div>        </div>      </div>      <template #action>        <n-button @click="cancelEditShortcut" :loading="onLoading" :disabled="onLoading">          {{ currentLanguage.pages.settings.editHotkeyModalCancelBtn }}        </n-button>        <n-button type="primary"                  :disabled="tempKeys.length === 0 || !availableKey || onLoading"                  @click="confirmEditShortcut"                  :loading="onLoading"        >          {{ currentLanguage.pages.settings.editHotkeyModalConfirmBtn }}        </n-button>      </template>    </n-modal>  </div></template><style scoped>.shortcut-display {  display: flex;  align-items: center;  justify-content: space-between;  border-radius: 6px;  background-color: var(--theme-background-secondary);  transition: background-color 0.2s;}.shortcut-keys {  display: flex;  flex-wrap: wrap;  gap: 8px;  align-items: center;}.key-plus {  font-weight: bold;  opacity: 0.7;  font-size: 14px;}.shortcut-display:hover {  background-color: var(--theme-background-hover);}.key-badge {  display: inline-block;  padding: 4px 10px;  background-color: var(--theme-divider);  border-radius: 6px;  font-size: 13px;  font-weight: 500;  color: var(--theme-text);}.edit-icon {  width: 20px;  display: flex;  justify-content: center;  align-items: center;  opacity: 0.5;  margin-left: 10px;  cursor: pointer;}.edit-icon:hover {  opacity: 1;}.shortcut-modal-content {  display: flex;  flex-direction: column;  gap: 16px;  padding: 10px 0;}.shortcut-hint {  display: flex;  font-size: 12px;  opacity: 0.5;  align-items: flex-start;  justify-content: flex-start;  flex-direction: row;  color: var(--theme-text);}.shortcut-hint-icon {  width: 30px;  margin-right: 6px;  padding-top: 5px;}.shortcut-keys-select {  flex-wrap: wrap;  font-size: 18px;  text-align: center;  background-color: var(--theme-divider);  border-radius: 6px;  padding: 2px 0;}.shortcut-line {  opacity: 0.8;  font-size: 14px;  margin-bottom: 15px;}.shortcut-verification {  display: flex;  align-items: center;}.shortcut-verification-icon {  width: 14px;  height: 14px;  margin-right: 4px;}.key-available {  color: rgb(62, 181, 3) !important;}.key-not-available {  color: rgb(214, 0, 0) !important;}</style>