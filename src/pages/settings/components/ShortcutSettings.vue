<script setup lang="ts">import {convertRegisterKeys, formatKeyDisplay, formatKeysDisplay} from "../../../utils/ShortcutKeysUtil.ts";import {currentShortcutKeys, onLoading, originalShortcutKeys} from "../composables/SettingsDataComposable.ts";import {useMessage} from "naive-ui";import {getQuickPasteKeyAvailable, getWakeUpRoutineKeyAvailable} from "../../../store/ShortcutKeyAvailableStatus.ts";import {  getQuickPaste,  getSearchKey,  getWakeUpRoutine,  saveQuickPasteKey,  saveSearchKey,  saveWakeUpRoutineKey} from "../../../store/ShortcutKeys.ts";import {error, info} from "@tauri-apps/plugin-log";import {isRegistered, register, unregister} from "@tauri-apps/plugin-global-shortcut";import {emit} from "@tauri-apps/api/event";import {isMac} from "../../../data/SystemParams.ts";import {onMounted, ref} from "vue";import {debounce} from 'lodash-es';import {currentLanguage} from "../../../services/LanguageService.ts";const message = useMessage();// 当前正在编辑的快捷键const editingShortcut = ref<keyof ShortcutKeys | ''>('');// 临时存储编辑中的按键const tempKeys = ref<string[]>([]);// 快捷键编辑弹窗状态const shortcutModalVisible = ref(false);// 初始的快捷键是否可用const initialKeyAvailableKey = ref(true);// 当前输入的快捷键是否可用const currentKeyAvailableKey = ref(true);// 初始的提示消息const initialHintText = ref(currentLanguage.value.pages.settings.keyAvailableHint);// 提示消息const currentHintText = ref(currentLanguage.value.pages.settings.keyAvailableHint);/** * 开始编辑快捷键 * @param key 快捷键类型 */function startEditShortcut(key: keyof ShortcutKeys) {  editingShortcut.value = key;  tempKeys.value = [...(currentShortcutKeys[key]?.key || [])];  shortcutModalVisible.value = true;  // 如果修改的是唤醒程序快捷键，需要检查快捷键是否可用  if (key.toString() === 'wakeUpRoutine') {    getWakeUpRoutineKeyAvailable().then(available => {      if (available === undefined) {        initialKeyAvailableKey.value = true;        currentKeyAvailableKey.value = true;      } else {        initialKeyAvailableKey.value = available;        currentKeyAvailableKey.value = available;      }      currentHintText.value = currentKeyAvailableKey.value ? currentLanguage.value.pages.settings.keyAvailableHint : currentLanguage.value.pages.settings.keyNotAvailableHint;      initialHintText.value = currentHintText.value;    });  } else if (key.toString() === 'quickPaste') {    const failedNumbers: number[] = [];    for (let i = 1; i <= 9; i++) {      getQuickPasteKeyAvailable(i).then(available => {        if (available !== undefined && !available) {          failedNumbers.push(i);        }      });    }    if (failedNumbers.length > 0) {      initialKeyAvailableKey.value = false;      currentKeyAvailableKey.value = false;      currentHintText.value = currentKeyAvailableKey.value ? currentLanguage.value.pages.settings.keyAvailableHint : currentLanguage.value.pages.settings.quickPasteKeyNotAvailableHint.replace("{keys}", failedNumbers.map(i => formatKeysDisplay([...currentShortcutKeys[key]?.key, String(i)])).join(","));      initialHintText.value = currentHintText.value;    }    tempKeys.value.push('[1-9]');  } else {    initialKeyAvailableKey.value = true;    currentKeyAvailableKey.value = true;  }  // 打开弹窗后添加全局按键监听  document.addEventListener('keydown', debouncedHandleKeyDown);}/** * 取消编辑快捷键 */function cancelEditShortcut() {  editingShortcut.value = '';  tempKeys.value = [];  shortcutModalVisible.value = false;  // 关闭弹窗后移除全局按键监听  document.removeEventListener('keydown', debouncedHandleKeyDown);}/** * 确认编辑快捷键 */async function confirmEditShortcut() {  try {    onLoading.value = true;    const key = editingShortcut.value;    if (key && tempKeys.value.length > 0) {      if (key.toString() === 'quickPaste') {        currentShortcutKeys[key].key = [...tempKeys.value.filter(key => key !== '[1-9]')];      } else {        currentShortcutKeys[key].key = [...tempKeys.value];      }    }    if (editingShortcut.value === 'wakeUpRoutine') {      await saveWakeUpRoutineKey(currentShortcutKeys[key]);      const keys: string[] = originalShortcutKeys.wakeUpRoutine.key;      info("唤醒程序快捷键已修改，重新注册");      // 取消注册快捷键      const registerKey = convertRegisterKeys(keys);      if (await isRegistered(registerKey)) {        // 如果已经注册了快捷键，需要先取消注册，再重新注册        await unregister(registerKey);      }      await emit('update-open-window-key', {keys: currentShortcutKeys});    }    if (editingShortcut.value === 'search') {      await saveSearchKey(currentShortcutKeys[key]);    }    if (editingShortcut.value === 'quickPaste') {      await saveQuickPasteKey(currentShortcutKeys[key]);      const keys: string[] = originalShortcutKeys.quickPaste.key;      info("快速粘贴快捷键已修改，重新注册");      // 取消注册快捷键      for (let i = 1; i < 9; i++) {        const registerKey = convertRegisterKeys([...keys, String(i)]);        if (await isRegistered(registerKey)) {          // 如果已经注册了快捷键，需要先取消注册，再重新注册          await unregister(registerKey);        }      }      await emit('update-quick-paste-key', {keys: currentShortcutKeys});    }    originalShortcutKeys[editingShortcut.value].key = currentShortcutKeys[editingShortcut.value].key;    editingShortcut.value = '';    tempKeys.value = [];    shortcutModalVisible.value = false;    // 关闭弹窗后移除全局按键监听    document.removeEventListener('keydown', debouncedHandleKeyDown);  } catch (e) {    error('修改快捷键设置出错:' + e);    message.error(currentLanguage.value.pages.settings.saveFailedMsg);  } finally {    onLoading.value = false;  }}/** * 处理按键事件 * @param event 事件 */const keyDowned = ref(true);const debouncedHandleKeyDown = debounce((event: KeyboardEvent) => {  handleKeyDown(event);}, 100);async function handleKeyDown(event: any) {  if (!keyDowned) {    return;  }  keyDowned.value = false;  event.preventDefault();  // 清除之前的按键  tempKeys.value = [];  // 添加修饰键  if (event.ctrlKey) tempKeys.value.push('ctrl');  if (event.shiftKey) tempKeys.value.push('shift');  if (event.altKey) tempKeys.value.push('alt');  if (event.metaKey) tempKeys.value.push('meta');  // 添加主键（如果不是修饰键）  const keyName = event.key.toLowerCase();  if (!['control', 'shift', 'alt', 'meta'].includes(keyName) && keyName !== 'dead') {    if (editingShortcut.value && editingShortcut.value.toString() === 'quickPaste') {      // 已经设置数字键了，不能再添加数字或者字母    } else {      tempKeys.value.push(keyName === ' ' ? 'space' : keyName);    }  }  // 如果修改的是唤醒程序快捷键，需要检查快捷键是否可用  if (editingShortcut.value && editingShortcut.value.toString() === 'wakeUpRoutine') {    const isRepeat = JSON.stringify(tempKeys.value) === JSON.stringify(currentShortcutKeys.search.key);    // 快捷键和搜索快捷键冲突    if (isRepeat) {      currentKeyAvailableKey.value = false;      currentHintText.value = currentLanguage.value.pages.settings.keyRepeatHint.replace('{keys}', currentLanguage.value.pages.settings.search);    } else {      await checkWakeUpRoutineKeys();    }  }  if (editingShortcut.value && editingShortcut.value.toString() === 'quickPaste') {    await checkQuickPasteKeys();  }  if (editingShortcut.value && editingShortcut.value.toString() === 'search') {    const isRepeat = JSON.stringify(tempKeys.value) === JSON.stringify(currentShortcutKeys.wakeUpRoutine.key);    // 快捷键和唤醒程序快捷键冲突    if (isRepeat) {      currentKeyAvailableKey.value = false;      currentHintText.value = currentLanguage.value.pages.settings.keyRepeatHint.replace('{keys}', currentLanguage.value.pages.settings.wakeUpRoutine);    }  }  keyDowned.value = true;}/** * 检查打开主窗口快捷键是否可用 */async function checkWakeUpRoutineKeys() {  const key = editingShortcut.value || "";  const isUpdate = JSON.stringify(currentShortcutKeys[key].key) !== JSON.stringify(tempKeys.value);  if (isUpdate) {    const keys = convertRegisterKeys(tempKeys.value);    try {      if (await isRegistered(keys)) {        currentKeyAvailableKey.value = false;      } else {        // 注册快捷键，判断是否可注册        await register(keys, () => {        });        await unregister(keys);        currentKeyAvailableKey.value = true;      }    } catch (e) {      currentKeyAvailableKey.value = false;    }    currentHintText.value = currentKeyAvailableKey.value ? currentLanguage.value.pages.settings.keyAvailableHint : currentLanguage.value.pages.settings.keyNotAvailableHint  } else {    currentKeyAvailableKey.value = initialKeyAvailableKey.value;    currentHintText.value = initialHintText.value;  }}/** * 检查快捷粘贴快捷键是否可用 */async function checkQuickPasteKeys() {  const key = editingShortcut.value || "";  const isUpdate = JSON.stringify(currentShortcutKeys[key].key) !== JSON.stringify(tempKeys.value);  if (isUpdate) {    const failedNumbers: number[] = [];    for (let i = 1; i <= 9; i++) {      const keys = convertRegisterKeys([...tempKeys.value, String(i)]);      try {        if (await isRegistered(keys)) {          failedNumbers.push(i);        } else {          await register(keys, () => {          });          await unregister(keys);        }      } catch (e) {        console.error("注册快捷键出错:" + e);        failedNumbers.push(i);      }    }    currentKeyAvailableKey.value = failedNumbers.length === 0;    currentHintText.value = currentKeyAvailableKey.value ? currentLanguage.value.pages.settings.keyAvailableHint : currentLanguage.value.pages.settings.quickPasteKeyNotAvailableHint.replace("{keys}", failedNumbers.map(i => formatKeysDisplay([...tempKeys.value, String(i)])).join(","));  } else {    currentKeyAvailableKey.value = initialKeyAvailableKey.value;    currentHintText.value = initialHintText.value;  }  tempKeys.value.push('[1-9]');}/** * 页面初始化 */onMounted(async () => {  try {    // 初始化快捷键配置    const searchKey = await getSearchKey();    originalShortcutKeys.search = structuredClone(searchKey);    currentShortcutKeys.search = structuredClone(searchKey);    const wakeUpRoutineKey = await getWakeUpRoutine();    originalShortcutKeys.wakeUpRoutine = structuredClone(wakeUpRoutineKey);    currentShortcutKeys.wakeUpRoutine = structuredClone(wakeUpRoutineKey);    const quickPasteKey = await getQuickPaste();    originalShortcutKeys.quickPaste = structuredClone(quickPasteKey);    currentShortcutKeys.quickPaste = structuredClone(quickPasteKey);  } catch (e) {    console.error('页面初始化失败:', e);    error("页面初始化失败：" + e);    message.error(currentLanguage.value.pages.settings.initFailedHint);  }});</script><template>  <div class="settings-section">    <n-divider title-placement="left">{{ currentLanguage.pages.settings.shortcutTitle }}</n-divider>    <div v-for="(shortcut, key) in currentShortcutKeys" :key="key" class="form-item">      <span class="label">{{ currentLanguage.pages.settings[key] }}</span>      <!-- 显示当前快捷键 -->      <div class="shortcut-display">        <div class="shortcut-keys">          <template v-for="(k, index) in shortcut.key" :key="index">            <span class="key-badge">{{ formatKeyDisplay(k) }}</span>            <span v-if="index < shortcut.key.length - 1" class="key-plus">+</span>          </template>          <span v-if="shortcut.name=== '快速粘贴'" class="key-plus">+</span>          <span v-if="shortcut.name=== '快速粘贴'" class="key-badge">1-9</span>        </div>        <span class="edit-icon" @click="startEditShortcut(key)">          <font-awesome-icon icon="fa-regular fa-pen-to-square"/>        </span>      </div>    </div>    <!-- 快捷键编辑弹窗 -->    <n-modal v-model:show="shortcutModalVisible" :title="currentLanguage.pages.settings.editHotkeyModalTitle"             preset="dialog">      <div class="shortcut-modal-content">        <p>{{ currentLanguage.pages.settings.editHotkeyModalContent }}</p>        <div class="shortcut-hint" v-if="!isMac">          <font-awesome-icon icon="fa-solid fa-circle-info" class="shortcut-hint-icon" />          {{ currentLanguage.pages.settings.shortcutHint }}        </div>        <div class="shortcut-keys-select">          {{            formatKeysDisplay(tempKeys) || currentLanguage.pages.settings.editHotkeyModalHint          }}        </div>        <div class="shortcut-line">          <div class="shortcut-verification" :class="currentKeyAvailableKey ? 'key-available': 'key-not-available'">            <font-awesome-icon icon="fa-solid fa-circle-check"  v-if="currentKeyAvailableKey" class="shortcut-verification-icon" />            <font-awesome-icon icon="fa-solid fa-circle-exclamation" v-else class="shortcut-verification-icon" />            {{ currentHintText }}          </div>        </div>      </div>      <template #action>        <n-button @click="cancelEditShortcut" :loading="onLoading" :disabled="onLoading">          {{ currentLanguage.pages.settings.editHotkeyModalCancelBtn }}        </n-button>        <n-button type="primary"                  :disabled="tempKeys.length === 0 || !currentKeyAvailableKey || onLoading"                  @click="confirmEditShortcut"                  :loading="onLoading"        >          {{ currentLanguage.pages.settings.editHotkeyModalConfirmBtn }}        </n-button>      </template>    </n-modal>  </div></template><style scoped>.shortcut-display {  display: flex;  align-items: center;  justify-content: space-between;  border-radius: 6px;  background-color: var(--theme-background-secondary);  transition: background-color 0.2s;}.shortcut-keys {  display: flex;  flex-wrap: wrap;  gap: 8px;  align-items: center;}.key-plus {  font-weight: bold;  opacity: 0.7;  font-size: 14px;}.shortcut-display:hover {  background-color: var(--theme-background-hover);}.key-badge {  display: inline-block;  padding: 4px 10px;  background-color: var(--theme-universal-border);  border-radius: 6px;  font-size: 13px;  font-weight: 500;  color: var(--theme-universal-text);}.edit-icon {  width: 20px;  display: flex;  justify-content: center;  align-items: center;  opacity: 0.5;  margin-left: 10px;  cursor: pointer;}.edit-icon:hover {  opacity: 1;}.shortcut-modal-content {  display: flex;  flex-direction: column;  gap: 16px;  padding: 10px 0;}.shortcut-hint {  display: flex;  font-size: 12px;  opacity: 0.5;  align-items: flex-start;  justify-content: flex-start;  flex-direction: row;  color: var(--theme-universal-text);}.shortcut-hint-icon {  width: 20px;  height: 20px;  margin-right: 6px;  padding-top: 5px;}.shortcut-keys-select {  flex-wrap: wrap;  font-size: 18px;  text-align: center;  background-color: var(--theme-universal-border);  border-radius: 6px;  padding: 2px 0;}.shortcut-line {  opacity: 0.8;  font-size: 14px;  margin-bottom: 15px;}.shortcut-verification {  display: flex;  align-items: center;}.shortcut-verification-icon {  width: 14px;  height: 14px;  margin-right: 4px;}.key-available {  color: rgb(62, 181, 3) !important;}.key-not-available {  color: rgb(214, 0, 0) !important;}</style>