import {Entry} from "@zip.js/zip.js";import {PackageTreeOption} from "../types/PackageTreeOption";import {NGradientText} from "naive-ui";import {convertFileSize} from "./FileUtil.ts";import {h} from "vue";import {utf8Decoder} from "../constants/PublicConstants.ts";import CloseFolderIcon from "../assets/icons/CloseFolderIcon.vue";import {packageMimeTypes} from "../constants/FileTypeConstatnts.ts";/** * 判断文件是否是压缩文件 * @param filePath 文件路径 */export function isPackage(filePath: string) {    const suffix = filePath.toLowerCase().split('.').pop() || '';    return packageMimeTypes[suffix] !== undefined;}/** * 获取文件类型 * @param filePath 文件路径 */export function getType(filePath: string) {    const ext = filePath.split('.').pop() || '';    return packageMimeTypes[ext] || '';}/** * 读取zip文件 * @param zipInfo zip文件信息 * @return 解压后的文件信息 */export async function readZipData(zipInfo: Entry[]) {    const arr: PackageInfo[] = [];    for (const entry of zipInfo) {        // 处理非UTF-8编码的文件名        if (!entry.filenameUTF8) {            entry.filename = utf8Decoder.decode(entry.rawFilename);        }        arr.push({            path: entry.filename,            dir: entry.directory,            date: entry.creationDate || new Date(),            size: entry.compressedSize,        });    }    return arr;}/** * 填充文件夹树 * @param packageInfos 包信息 */export function convertChildren(packageInfos: PackageInfo[]) {    const children: PackageTreeOption[] = [];    let fileCount = 0;    // 先处理文件夹    for (const info of packageInfos) {        if (info.dir) {            // 移除文件夹最后一个字符，最后一个字符是“/”，不需要展示            const name = info.path.endsWith("/") ? info.path.substring(0, info.path.lastIndexOf('/')) : info.path;            if (name.indexOf('/') > -1 && !name.endsWith('/')) {                addPathToTree(children, name);            } else {                children.push({                    key: name,                    label: name.split('/').pop() || '',                    children: [],                    date: info.date,                    prefix: () => h(CloseFolderIcon, null, {default: () => h(CloseFolderIcon)}),                })            }            fileCount++;        }    }    // 再处理文件    for (const info of packageInfos) {        if (!info.dir) {            // 组装文件对象            const data: PackageTreeOption = {                key: info.path,                label: info.path.split('/').pop() || '',                date: info.date,                suffix: () => h(NGradientText, {type: 'success'}, {                    default: () => {                        return convertFileSize(info.size)                    }                })            }            if (info.path.indexOf('/') > -1) {                // 文件在子目录中，需要找到对应目录并添加文件                const dirPath = info.path.substring(0, info.path.lastIndexOf('/')); // 获取目录路径                // 查找并添加到对应目录                addToDirectory(children, dirPath, data);            } else {                children.push(data);            }            fileCount++;        }    }    // 排序并更新文件计数显示    sortTreeNodes(children);    // 递归更新所有文件夹的文件计数    updateAllFolderCounts(children);    return children;}/** * 填充子文件夹 * @param tree 文件夹树 * @param path 文件夹路径 */function addPathToTree(tree: PackageTreeOption[], path: string) {    const parts = path.split('/');    let currentNode: PackageTreeOption[] = tree;    // 处理多级路径    for (let i = 0; i < parts.length; i++) {        const part = parts[i];        // 获取当前层级的父路径        const parentPath = parts.slice(0, i + 1).join('/');        // 查找当前层级是否已存在该节点        let existingNode = currentNode.find(node => node.key === parentPath);        if (!existingNode) {            // 创建新节点            existingNode = {                key: path,                label: part,                children: [],                prefix: () => h(CloseFolderIcon, null, {default: () => h(CloseFolderIcon)}),            };            currentNode.push(existingNode);        }        // 移动到下一层级        currentNode = existingNode.children || [];    }}/** * 填充文件 * @param tree 文件夹树 * @param dirPath 文件夹路径 * @param fileNode 文件节点 */function addToDirectory(tree: PackageTreeOption[], dirPath: string, fileNode: PackageTreeOption) {    const parts = dirPath.split('/');    let currentNode: PackageTreeOption[] = tree;    // 遍历目录路径找到目标目录    for (let i = 0; i < parts.length; i++) {        const part = parts[i];        const key = parts.slice(0, i + 1).join('/');        let existingNode = currentNode.find(node => node.key === key);        if (!existingNode) {            // 目录不存在，创建新的文件夹节点            existingNode = {                key: key,                label: part,                children: [],                prefix: () => h(CloseFolderIcon, null, {default: () => h(CloseFolderIcon)}),            };            currentNode.push(existingNode);        }        if (i === parts.length - 1) {            // 到达目标目录，添加文件            if (existingNode.children) {                existingNode.children.push(fileNode);            } else {                existingNode.children = [fileNode];            }            return;        } else {            // 继续向下查找            currentNode = existingNode.children || [];        }    }}/** * 递归更新所有文件夹的文件数 * @param nodes 文件夹节点 */function updateAllFolderCounts(nodes: PackageTreeOption[]) {    nodes.forEach(node => {        if (node.children) {            // 计算该文件夹下的总文件数            node.fileCount = calculateFileCount(node.children);            // 更新显示标签            if (node.fileCount > 0) {                node.suffix = () => h(NGradientText, {type: 'success'}, {                    default: () => {                        return node.fileCount + "个文件";                    }                });            }            // 递归更新子文件夹            updateAllFolderCounts(node.children);        }    });}/** * 排序文件夹树 * @param nodes 文件夹节点 */function sortTreeNodes(nodes: PackageTreeOption[]) {    nodes.sort((a, b) => {        // 如果都是文件夹或都是文件，按日期排序        if ((a.children && b.children) || (!a.children && !b.children)) {            return new Date(a.date || new Date()).getTime() - new Date(b.date || new Date()).getTime();        }        // 文件夹优先（children 存在表示是文件夹）        if (a.children && !b.children) {            return -1;        }        if (!a.children && b.children) {            return 1;        }        return 0;    });    // 更新文件夹标签以显示文件个数    nodes.forEach(node => {        if (node.children) {            // 更新文件夹的suffix显示文件个数            if ((node.fileCount || 0) > 0) {                node.suffix = () => h(NGradientText, {type: 'success'}, {                    default: () => {                        return node.fileCount + "个文件";                    }                });            }            // 递归排序子节点            if (node.children.length > 0) {                sortTreeNodes(node.children);            }        }    });}/** * 计算文件夹下的文件数 * @param nodes 文件夹节点 */function calculateFileCount(nodes: PackageTreeOption[]) {    let count = 0;    nodes.forEach(node => {        if (node.children) {            // 是文件夹，递归计算子节点            count += 1;            count += calculateFileCount(node.children);        } else {            // 是文件，计数加1            count += 1;        }    });    return count;}